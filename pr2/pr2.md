# Хвостовая и взаимная рекурсия

[Интерактивная версия](https://sketch.sh/s/xKoWxeX93fkWWKDYG9OsHA/)

# Хвостовые вызовы

Основой функциональной декомпозиции, естественно, являются функции, в том числе рекурсивные. Рекурсивные функции для многих задач получаются проще, короче и элегантнее, чем цикл. Кроме того, они хорошо сочетаются с преимущественно неизменяемыми данными. Но зато возникают вопросы, связанные с эффективностью реализации рекурсивных вызовов.

## Стек вызовов

На каждый вызов функции в стеке создаётся запись (stack frame, activation record), которая содержит локальные переменные и адрес возврата. Размер стека обычно сильно ограничен, и, в случае неэффективного использования рекурсии, он очень быстро заканчивается. Этот эффект можно легко продемонстрировать на примере (факториал вычисляется по модулю простого числа, чтобы избежать переполнения целых):

```ocaml
let rec fact n =
  if n = 0
    then 1
    else (n * fact(n - 1)) mod 105943;;

let ok = fact 1000;;
(* Uncomment to get stack overflow *)
(* let oops = fact 10000;; *)
```

Что делать? Давайте немного перепишем функцию:

```ocaml
let fact n =
 let rec aux(n, acc) =
   if n = 0
     then acc
     else aux(n - 1, (acc * n) mod 105943)
 in aux(n, 1);;

let ok = fact 10000;;
```

Теперь всё работает. Что изменилось? Мы добавили вспомогательную функцию `aux`, которая принимает два параметра, в одном из которых аккумулирует результат. По достижении базы рекурсии результат сразу возвращается, дополнительных вычислений с результатом рекурсивного вызова тоже не происходит. Имено тот факт, что после рекурсивного вызова больше ничего вычислять не нужно, позволяет компилятору переиспользовать один и тот же стекфрейм! В результате такая функция выполняется на константом стеке. Это называется **оптимизацией хвостовых вызовов**. Такая оптимизация реализована в языках с преимущественно функциональной парадигмой, но встречается и в компиляторах обычного C.

## Применение

Итак, там где это важно, и там где это достижимо, следует переписать функцию так, чтобы все вызовы были хвостовыми. Общее правило такое:
- Добавляем вспомогательную функию, которая принимает аккумулятор результата
- Бывшая база рекурсии становится начальным значением аккумулятора
- Новой базой становится конечное значение аккумулятора

Пример: суммирование элементов списка

```ocaml
let rec sum xs =
 match xs with
   [] -> 0
   | head::tail -> head + sum tail;;
   
let sum_tail xs =
 let rec aux (xs, acc) =
   match xs with
     []-> acc
     | head::tail -> aux(tail, head + acc)
 in aux(xs, 0);;
```

Разворот списка:

```ocaml
let rec rev xs =
 match xs with
 [] -> []
 | head::tail -> rev (tail) @ [head];;

let r = rev [1; 2; 3];;
```

Обратите внимание, что нехвостовая версия функции, разворачивающей список, в общем случае имеет квадратичную сложность: используется оператор склеивания списков `@` с линейной сложностью.

```ocaml
let rev xs = 
  let rec aux (xs, acc) =
    match xs with
      [] -> acc
      | head::tail -> aux (tail, head::acc)
  in aux (xs, []);;

let r = rev [1; 2; 3];;
```

Хвостовая версия лишена этого недостатка, потому что мы вывернули вычисление наизнанку, и нет нужды теперь добавлять элементы в конец списка. С этим эффектом нужно быть осторожнее, потому что может получиться и наоборот - при переписывании функции в форме хвостовой рекурсии результат может получиться не в том порядке, либо функция из линейной становится квадратичной за счёт того, что приходится добавлять элементы в конец списка. В этом случае лучше развернуть итоговый список, чтобы не ухудшать асимптотику вашего алгоритма.

## Определение хвостового вызова

**Хвостовой вызов** - это вызов функции, который находится в **хвостовой позиции**, а именно:

- Если выражение находится не в хвостовой позиции, то все его выражени тоже находятся не в хвостовой позиции
- В выражении `let f p = e` (определение функции) тело e находится в хвостовой позиции
- Если выражение `if e1 then e2 else e3` находится в хвостовой позиции, то e2 и e3 тоже находятся в хвостовой позиции, а выражение e1 - нет
- Если выражение `let b in e` находится в хвостовой позиции, то выражение e тоже находится в хвостовой позиции, а выражение b - нет
- Аргументы вызываемой функции не находятся в хвостовой позиции.

Всегда ли можно переписать функцию так, чтобы вызовы были хвостовыми? (вопрос на подумать).
Всегда ли это выгодно? Нет, не всегда. При обработке древовидных структур данных может получиться трудночитаемый код с ручной эмуляцией стека. Поэтому стоит всегда помнить о том, что преждевременная оптимизация является корнем всех зол. Так что прежде всего - понятный, читаемый, лаконичный код, который решает задачу. А уж оптимизировать его нужно только при необходимости.

# Взаимно рекурсивные функции

Как мы помним, связывания верхнего уровня в OCaml обрабатываются и попадают в статическое окружение последовательно. Поэтому нельзя просто так определить взаимно рекурсивные функции:

```ocaml
(* Uncomment to get unbound value error *)

(* let rec even n =
  n = 0 || odd (x-1);;
    
 let rec odd n =
   n = 0 || even (x-1);; *)
```

Для определения взаимно рекурсивных сущностей (как функций, так и типов) в OCaml есть специальное ключевое слово and:

```ocaml
let rec even n =
  if n = 0 then true else odd (n-1)
    
and odd n =
  if n = 0 then false else even (n-1);;
   
even 11;;
odd 15;;
```

Пример с взаимно рекурсивными типами - выражение деревьев через список других деревьев (`forest`):

```ocaml
type 'a tree = Empty | Node of 'a * 'a forest
and 'a forest = Nil | Cons of 'a tree * 'a forest
```

Классический пример использования взаимной рекурсии - конечный автомат. Состояние - это функция, которая принимает входную цепочку, в зависимости от текущего символа которой происходит переход в другие состояния.

```ocaml
let rec state1 lst =
  match lst with
    [] -> true
    | 'a'::tail -> state2 tail
    |_ -> false
and state2 lst =
  match lst with
    [] -> false
    | 'b'::tail -> state1 tail
    | _ -> false;;
    
state1 ['a'; 'b'; 'a'];;
state1 ['a'; 'b'];;
state1 ['a'; 'a'];;
```

# Задачи

1. Напишите хвостовую функцию `make_list: int -> int list`, которая принимает положительное число n и возвращает список чисел от 1 до n.

```ocaml
assert (make_list 2 = [1; 2]);;
```

2. Напишите хвостовую функцию `range: int -> int -> int list`, которая принимает два целых числа a и b, причём a <= b, и возвращает список всех чисел из диапазона от a до b (не включая правую границу). 

```ocaml
assert ((range 4 4) = []);;
assert ((range 3 5) = [3; 4]);;
```
