# Основы Ruby

**Ruby** - динамически-типизированный, объектно-ориентированный язык, придуманный Юкихиро Мацумото. Появился в 1995 году. Язык задумывался таким же простым, как Lisp, и таким же объектно-ориентированным на всю голову, как Smalltalk. Кроме того, одной из основных идей, связанных с Ruby, было стремление сделать разработчиков счастливыми и продуктивными *(кстати, авторы каких ещё языков заявляют это одной из целей их разработки?).*

В Ruby довольно много любопытных и даже странных особенностей, но наш курс фокусируется главным образом на некоторых из них:

* Ruby совсем объектно-ориентированный, то есть абсолютно все сущности в нём являются объектами (например, константа 42 в Ruby - объект, а в Java - нет).

* Ruby относится к class-based языкам. То есть любой объект - это экземпляр некоего класса. Класс определяет методы, которые могут вызываться у объекта. Весь код на Ruby находится именно в методах.

* В Ruby есть миксины - компромисс между интерфейсами и множественным наследованием поведения.

* Ruby динамически-типизированный: он позволяет вызвать любой метод у любого объекта с любыми аргументами. Если вдруг у объекта не окажется соответствующего метода, мы получим ошибку времени выполнения.

* У Ruby удобная рефлексия: во время выполнения можно исследовать свойства объектов: узнать, к какому классу принадлежит объект, получить список его методов и т.д.

* В Ruby, кроме замыканий, есть блоки - "почти замыкания", являющиеся объектами второго класса. Блоки менее мощные, но простые и покрывают множество сценариев использования.

## Объекты, классы, переменные, методы

### Определение классов и методов

Синтаксис создания класса `Foo` с методами `m1, m2 ... mn`  следующий:

```ruby
class Foo
  def m1
  ...
  end
  def m2 (x,y)
  ...
  end
  ...
  def mn z
  ...
  end
end
```

Имена классов должны начинаться с большой буквы. У метода может быть произвольное количество параметров, в том числе 0. Метод неявно возвращает результат своего последнего выражения, но при необходимости можно явно указать `return`. У параметров могут быть значения по умолчанию:

```ruby
def myMethod (x, y, z=0, w="hi")
...
end
```

Если у параметра есть значение по умолчанию, то у всех параметров правее него они тоже обязаны быть.

### Вызов методов

Синтаксис вызова метода - привычный:

```ruby
 e0.m(e1, ..., en)
```

Сначала вычисляются выражения `e0, e1, ... en`, в результате получаются объекты. Затем у объекта, в который вычислилось выражение `e0`, вызывается метод `m` с соответствующими аргументами. Скобки опциональны и могут опускаться.

Чтобы вызвать метод текущего объекта (того самого, чей метод исполняется в данный момент), можно писать `self.m(...)` или просто `m(...)`.

### Поля объекта (instance variables)

В отличие от многих других языков, классы в Ruby не определяют, какие у их объекта (экземпляра) могут быть поля. Чтобы добавить поле в объект, нужно просто присвоить туда что-нибудь. Все имена полей объекта начинаются с @, например, `@foo`. Это нужно для того6 чтобы отличать поля от локальных переменных метода.

У каждого объекта имеется свой набор полей. Поля изменяемые (в них можно присваивать) и приватные по отношению к объекту (к ним нельзя обратиться снаружи объекта).

**Поля класса** (class variables) общие для всех объектов класса. Обратиться к ним можно так - `@@foo`. Они тоже приватны (к ним нельзя обратиться из объекта другого класса).

### Создание объкта

```ruby
Foo.new(...)
```

`new` создаёт новый объкет класса `Foo` и вызывает у него специальный метод `initialize`, который играет роль конструктора. Хорошей практикой считается создавать в этом методе поля объекта и не создавать их в других методах. Но поскольку это только соглашение, разные объекты одного и того же класса могут иметь разный набор полей.

```ruby
class A
  def m1
    @foo = 0
  end

  def m2 x
    @foo += x
  end

  def foo
    @foo
  end
end

class B 
    # uses initialize method with parameters
    def initialize(f=0)
      @foo = f
    end
  
    def m2 x
      @foo += x
    end
  
    def foo
      @foo
    end
end
```

## Выражения и локальные переменные

Большинство выражений в Ruby - то вызовы методов. Например, `e1 + e2` - это просто синтаксический сахар для `e1.+ e2`, то есть вызов метода `+` у результата вычисления выражения `e1` с результатом вычисления `e2` в качестве аргумента. Но, конечно, это касается не всех выражений. Например, существует несколько разновидностей условных выражений.

```ruby
def gcd(x,y)
    if x == y
      x
    elsif x < y
      gcd(x,y-x)
    else
      gcd(y,x)
    end
end
```

Как и поля объекта, локальные переменные внутри метода не требуют объявления. Переменная создаётся в момент первого присваивания. Областью видимости переменной является **целиком тело метода**. Обращение к локальной перменной до её инициализации приведёт к ошибке времени выполнения. В отличие от полей: обращение к непроинициализированному полю вернёт `nil`.

## Константы и методы класса

Константы уровня класса, в отличие от переменных класса:
* Пишутся с большой буквы и без @@
* Нельзя изменять
* Видимы за пределами класса
  
Странноватый синтаксис, чтобы определить метод класса:

```ruby
class Y
    def self.y_class_method
        puts "I'm a class method"
    end
end

Y.y_class_method
```

В отличие от обычных методов объекта (instance methods) у метода класса нет доступа ни к каким полям или методам объекта. Это аналог статических методов в других языках.

## Видимость, геттеры и сеттеры

Как уже упоминалось выше, поля объекта приватны: к этим полям могут обращаться только методы, вызванные у этого объекта. Даже другие объекты того же самого класса не имеют доступа к этим полям.

У методов может быть разная видимость. По умолчанию это `public` (любой объект может вызвать этот метод). Кроме `public` есть ещё `private` и `protected` - всё как у людей. Видимость обозначается соответствующим ключевым словом, которое влияет на все объявления ниже него, пока эта видимость не будет изменена.

Чтобы предоставить доступ к полю объекта на чтение, либо сделать его изменяемым извне, можно объявить геттеры и сеттеры:

```ruby
def foo
    @foo
end

def foo= x
    @foo = x
end
```

Если эти методы объявлены как public, обратиться к полю `@foo` можно будет просто вызвав соответствующий метод - `foo` или `foo=`. В качестве синтаксического сахара, в случае вызова сеттера вы можете поставить пробел перед символом `=`:

```ruby
e.foo = bar
```

То есть, на самом деле, вы вызываете метод `foo=`, а пишется это так, будто вы присваиваете что-то полю `foo`. Придумают же.

Польза геттеров и сеттеров:

* То, что эти специальные методы читают или пишут поле объекта - всего лишь деталь реализации, скрытая от клиентского кода. При необходимости можно изменить логику геттеров и сеттеров, а клиент об этом ничего не узнает.
* Сеттер можно опустить, тогда поле объекта никто не сможет изменить извне.

Например, у нас был класс с полем, хранящим температуру в градусах Цельсия, а у поля - соответствующий сеттер:

```ruby
def celcius_temp= x
    @celcius_temp = x
end
```

Затем мы изменили реализацию класса так, что температура всегда хранится в градусах Кельвина:

```ruby
def celcius_temp= x
    @kelvin_temp = x + 273.15
end
```

Для клиентского кода ничего не изменилось.

Геттеры и сеттеры используются весьма часто, поэтому для более краткого их определения существует синтаксический сахар:

```ruby
attr_reader :y, :z # defines getters for y and z
attr_accessor :x # defines getter and setter for x
```

# Задачи

Напишите класс `Point`, описывающий точку на плоскости. Храните координаты так, как считаете целесообразным. Для удобства воспользуйтесь модулем Math. Интерфейс должен быть следующим:

1. Конструктор принимает координаты `x` и `y`
2. Геттеры `x`, `y` для соответствующих координат точки. Сеттеров нет - поля `x` и `y` только для чтения.
3. Методы `rotate_left` и `rotate_right`, которые принимают угол в радианах и соответствующим образом изменяют координаты точки. В качестве результата методы должны возвращать `self`, чтобы можно было писать примерно так:
   ```ruby
   point.rotate_left(Math::PI).rotate_right(Math::PI*0.25).x
   ```
Заготовка для класса и примеры тестов приведены в файле pr4.rb.