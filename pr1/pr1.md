# Основы языка OCaml

```ocaml
"Hello, world"
```

[Интерактивная версия](https://sketch.sh/s/dLfXR7M8CL8TqeJ8ITpBRk/)

В этой небольшой работе мы познакомимся с базовыми конструкциями языка OCaml, их синтаксисом и семантикой. Предполагается, что этот язык для вас совершенно новый, поэтому стоит на время забыть те языки, что вы уже знаете, и вдумчиво разобраться даже с теми вещами, которые кажутся простыми. Рекомендую набирать код целиком, избегая копирования. Кроме того, несмотря на то, что OCaml позволяет не указывать типы явно, в этой работе всё же стоит это делать. Автоматический же вывод типов мы обсудим чуть позже.

Не стесняйтесь экспериментировать с кодом примеров, пробуйте что-то изменить и запустить, смотрите, что получается. В конце приведено несколько заданий для самостоятельного выполнения.

Удачи!

# Связывание значений. Синтаксис и семантика.

Рассмотрим одну из самых базовых конструкций языка — связывание имени и значения (let binding):
`let x = e`
где `x` — это имя, а `e` — выражение языка.
Есть две важных вещи, которые мы можем узнать о любой конструкции языка — её *синтаксис* и *семантика*.

**Синтаксис** — это правила, по которым конструкция *пишется*. В случае связывания переменной `let` — это ключевое слово, `x` — это имя переменной (я буду называть это переменной, но на самом деле значения в OCaml — неизменяемые), `e` — это выражение (арифметическое, логическое, вызов функции, `if` и так далее).

**Семантика** — это то, что конструкция или выражение *означает*. Существует несколько способов строго описывать семантику языка (например, денотационная или операционная семантика), но для нашего курса достаточно словесного описания. В нашем случае семантика состоит из двух частей:

- то, что происходит во время компиляции
- то, что происходит во время выполнения

**Семантика связывания переменных**:

Во время компиляции:

- проверка типов для выражения `e`
- если проверка типов успешна, то переменной `x` присваивается полученный тип `T`.
- Данные о типе переменной `x` сохраняются в статическом окружении.

Во время выполнения:

- выражение `e` вычисляется в соответствии с его семантикой
- полученное значение сохраняется за переменной `x` в динамическом окружении.

Итак, исследуя очередной вид выражений изучаемого языка, будем отвечать на три вопроса:

- Синтаксис этого выражения
- Правила проверки типов
- Правила вычисления

# Основные виды выражений

## Переменные

**Синтаксис**: Латинские буквы, цифры, символы `_` и `'`
Идентификатор должен начинаться со строчной буквы или символа `_`

**Проверка типов**: Поиск имени в текущем *статическом окружении*. Если имя не найдено — получаем ошибку.

**Вычисление**: Поиск связанного значения в текущем *динамическом окружении*

```ocaml
let _x' = 43;;
_x'
(* Uncomment to get unbound value error *)
(* abcd *)
```

## Целочисленное сложение

**Синтаксис**: `e1 + e2`

**Проверка типов**: если тип `e1` и `e2` — `int`, то тип `e1 + e2` — `int` (Иначе — type error, далее это подразумевается везде)

**Вычисление**: Если значение `e1` равно `v1`, а значение `e2` равно `v2`, то значение `e1 + e2` равно `v1 + v2`

```ocaml
let x = 43;;
let y = 42;;
x + y
```

## Сложение чисел с плавающей точкой

**Синтаксис**: `e1 +. e2`

**Проверка типов**: если тип `e1` и `e2` — `float`, то тип `e1 +. e2` — `float`

**Вычисление**: Если значение `e1` равно `v1`, а значение `e2` равно `v2`, то значение `e1 +. e2` равно `v1 + v2`

```ocaml
let x = 42.0;;
let y = 43.0;;
(* Uncomment to get type error and fix *)
(* x + y *)
```

## Значения (Value)

Значения бывают разных типов (логические, числа, строки и т.п.).
Всякое значение — это выражение, но не всякое выражение — значение.
Значение вычисляется само в себя за 0 шагов.

```ocaml
false;;
"Hello";;
42;;
```

## Условное выражение

**Синтаксис**: `if e1 then e2 else e3`
где `e1`, `e2`, `e3` — выражения

**Проверка типов**: если тип `e1` — `bool`, а тип `e2` и `e3` — `T` (любой тип, но одинаковый), то тип `if e1 then e2 else e3` - `T`

**Вычисление**: пусть значение `e1` равно `v1`, значение `e2` равно `v2`, а значение `e3` равно `v3`. Тогда если `v1 = true`, то значение всего выражения равно `v2`, иначе - `v3`.

Обратите внимание, что конструкция `if ... then ... else` в OCaml является **выражением**, то есть его значение можно куда-то присвоить, вернуть как результат, передать в качестве аргумента и так далее.

```ocaml
let x = 42;;
let y = 43;;
if x < y then x + y else x - y
let min_xy = if x < y then x else y
```

## Функции

**Синтаксис**: `let f (x1 : t1) (x2 : t2) ... : t = e`
где `f` — имя функции, `x1`, `x2` ... — имена аргументов, `t1`, `t2` ... — типы аргументов, `t` — тип возвращаемого значения, `e` — выражение (тело функции)

**Проверка типов**:
выражение `e` типизируется в текущем статическом окружении, дополненном аргументами `x1 : t1`, `x2 : t2` и т.д. Если при этом тип выражения `e` равен `t`, статическое окружение дополняется связыванием `f : t1 -> t2 -> ... -> t` (Значение `f` становится доступным ниже места его определения).
В определении функции типы могут опускаться. Но о том, как это работает, поговорим позже.

**Вычисление**:
в окружение добавляется значение с именем `f` и типом `t1 -> t2 -> ... -> t`

```ocaml
let sum (a: int) (b : int): int = a + b
let min (a : int) (b : int) : int = if a < b then a else b
```

## Рекурсивные функции

**Синтаксис**: `let rec f (x1 : t1) (x2 : t2) ... : t = e`

**Проверка типов**:
выражение `e` типизируется в текущем статическом окружении, дополненном аргументами `x1 : t1`, `x2 : t2` ... и связыванием `f : t1 -> t2 -> ... -> t`. Если при этом тип выражения `e` равен `t`,  текущее статическое окружение дополняется связыванием `f : t1 -> t2 -> ... -> t`. За счёт того, что окружение для типизации выражения e дополняется самой функцией, мы получаем возможность ссылаться на неё в теле.

**Вычисление**:
в окружение добавляется значение с именем `f` и типом `t1 -> t2 -> ... -> t`

```ocaml
let rec fact (x : int) : int = 
  if x = 1 then x else x * fact (x - 1)
```

## Вызов функций

**Синтаксис**: `e0 e1 ... en`

**Проверка типов**:
Если `e0` имеет тип `t1 -> ... -> tn -> t`, то `e0 e1 ... en` имеет тип `t`

**Вычисление**:

- В текущем динамическом окружении вычисляется `e0`, получается функция `x0 : (x1 : t1 -> ... -> xn : tn) : t = e`
- В текущем динамическом окружении вычисляются выражения `e1`, `e2` ... `en`, получаем значения `v1`, ... `vn`
- В текущем окружении, дополненном `x1 : v1`, ... `xn : vn` вычисляем `e`. Если функция рекурсивная, то выражение `e` вычисляется в окружении, дополненном ещё и значением `x0`

```ocaml
fact 6;;
min x y;;
```

## Локальные let и ограничения области видимости

**Синтаксис**: `let b in e`,
Где `b` - это связывание вида `x = e0`

**Проверка типов**:

- В текущем статическом окружении проверяем типы для `b`
- Если в результате `b` имеет тип `t0`, то происходит проверка типов для `e` в текущем статическом окружении, дополненном связыванием `x : t0`.
- Если выражение `e` имеет тип `t`, то всё выражение имеет тип `t`.

**Вычисление**:

Вычисление происходит аналогично проверке типов.

Локальные `let`-выражения можно вкладывать друг в друга (и в другие выражения) с произвольной глубиной. С их помощью можно управлять *областью видимости* связываний. Связывания верхнего уровня видны всюду ниже их определения. Локальные связывания видны только внутри выражения после `in`. Функции можно определять локально точно так же, как выражения.

```ocaml
let x = 42 in x*x

let dist_to_origin (x: float) (y: float) =
    let sqr (z : float) = z*.z (* local helper function *)
      in sqrt (sqr x +. sqr y);; (* values from outer scope are still visible *)
 (* sqr function isn't visible outside of it's scope *)
 (* Uncomment to get unbound value error *)
 (* sqr 42.0;; *)
 ```

# Составные типы данных

Простейшие типы данных, такие как числа, строки или логические значения, мы уже видели. Рассмотрим теперь несколько основных составных типов. Для любого сложного типа нам нужно знать две вещи:

- Как сконструировать значение сложного типа из других значений
- Как получить доступ к составным частям значения сложного типа

## Кортежи (tuples)

Кортежи состоят из фиксированного количества элементов, возможно разных типов. Частный случай кортежа — пара. Всё, что справедливо для пар, обобщается и для кортежей с большим количеством элементов, за исключением встроенных функций доступа к элементам.

### Создание пар

**Синтаксис**: `(e1, e2)`
Где `e1` и `e2` — выражения. В некоторых случаях скобки могут опускаться (там, где не возникает неоднозначностей).

**Проверка типов**

Если `e1` имеет тип `t1`, а `e2` — тип `t2`, то `(e1, e2)` имеет тип `t1 * t2`

**Вычисление**:

- Вычисляем `e1`, получаем значение `v1`
- Вычисляем `e2`, получаем значение `v2`
- Значение всего выражения - пара `(v1, v2)`

```ocaml
let pair = ("foo", 42)
```

### Доступ к элементам пар

Встроенные функции `fst` и `snd` для первого и второго элемента соответственно. Более идиоматичный и удобный способ доступа рассмотрим чуть позднее.

```ocaml
fst pair;;
snd pair;;
```

## Списки

Списки могут содержать произвольное количество элементов, но обязательно одного и того же типа.
Пустой список создаётся так:

```ocaml
let a = []
```

### Задание списка конкретных значений:

**Синтаксис**

Список из конкретных значений `[e1; e2; ... en]`

**Проверка типов**

Если выражения `e1`; `e2` ... `en` имеют тип `t`, то список имеет тип `t list`

**Вычисление**

Если `e1`; `e2`; ... `en` вычисляются в `v1`; `v2` ... `vn`, то выражение `[e1; e2; ... en]` вычисляется в значение `[v1; v2; ... vn]`

```ocaml
[3; 4; 5];;
(* Be carefull with commas: *)
[3, 4, 5];;
```

### Создание нового списка добавлением элемента в начало

**Синтаксис**:
`e1::e2`

**Проверка типов**

Если выражение `e1` имеет тип `t`, а выражение `e2` — тип `t list`, то выражение `e1::e2` имеет тип `t list`

**Вычисление**

Если выражение `e1` вычисляется в `v`, а выражение `e2` вычисляется в `[v1; ...vn]`, то `e1::e2` вычисляется в `[v; v1; ... vn]`

Обратите внимание, что списки по-прежнему *неизменяемые*, то есть при использовании `::` создаётся новый список и не меняется старый.

```ocaml
let b = 42::a;;
let c = 43::b;;
1::2::3::4::[]
```

### Доступ к голове и хвосту списка

Функции `List.hd` и `List.tl`. Более красивый и идиоматичный способ доступа рассмотрим позже.

```ocaml
List.hd b;;
List.tl b
```

# Задачи

Теперь, используя всё изученное выше, напишите несколько функций. Типы указаны в комментарии, кроме того, для вашего удобства уже написано несколько тестов. Обратите внимание, что `=` используется для сравнения *значений*, а `==` - для сравнения *ссылок*. Списки можно проверять на пустоту сравнением с `[]`.

1. Напишите функцию `get_max`, которая принимает три целочисленных значения и возвращает максимальное из них. Можно использовать локальные вспомогательные функции или обойтись выражением `if`

```ocaml
(* get_max: int -> int -> int -> int *)


assert ((get_max 4 5 6) = 6);;
assert ((get_max 5 1 1) = 5);;
assert ((get_max 1 2 1) = 2);;
```

2. Напишите рекурсивную функцию `sum_all`, суммирующую элементы списка.

```ocaml
(* sum_all: int list -> int *)

    
assert (sum_all [4] = 4);;
assert (sum_all [] = 0);;
assert (sum_all [-1; -1] = -2);;
```

3. Напишите рекурсивную функцию `get_heads`, которая принимает список списков целых чисел и возвращает список, содержащий их головы. Считайте, что пустых списков исходный список не содержит.

```ocaml
(* get_heads: int list list -> int list *)



assert (get_heads [[1]; [2]; [3]] = [1; 2; 3]);;
```

4. Напишите рекурсивную функцию `get_heads_str`, которая принимает список списков строк и возвращает список, содержащий их головы. Для пустых списков используйте значение `"DEFAULT"`.

```ocaml
(* get_heads_str: string list list -> string list *)


assert (get_heads_str [ [] ] = ["DEFAULT"]);; 
assert (get_heads_str [ ["a"; "b"]; ["c"]] = ["a"; "c"]);;
```

5. Напишите функцию `gen_range`, которая принимает пару целых чисел `pair = (a, b)` и возвращает список всех чисел из диапазона `[a, b]`. Если `a > b`, возвращайте пустой список.

```ocaml
(* gen_range: int * int -> int list *)


assert (gen_range (2, 1) = []);;
assert (gen_range (2, 2) = [2]);;
assert (gen_range (2, 3) = [2; 3]);;
assert (gen_range (2, 4) = [2; 3; 4]);;
```

6. Напишите функцию `concat_list`, которая принимает список строк и строку-разделитель, и возвращает строку, полученную склейкой всех строк из списка с разделителем. Для пустого списка возвращайте пустую строку. Для склеивания строк используйте оператор `^`

```ocaml
(* concat_list: string list -> string -> string *)


assert (concat_list [] "; " = "");;
assert (concat_list ["a"] "; " = "a");;
assert (concat_list ["a"; "b"] "; " = "a; b");;
```

