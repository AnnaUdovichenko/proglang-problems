# Маленькая скучная лаба

Язык: **OCaml**

Максимальное количество баллов: **10**

*В данной работе нужно будет написать несколько функций, пользуясь автоматическим выводом типов (явно указывать типы не нужно), сопоставлением с образцом (вся работа со списками, кортежами, вариантами и записями должна быть через pattern matching, без функций типа List.hd или fst), и частичным применением аргументов. Функции высшего порядка по возможности определяйте как значения (point-free). Если требуется определить вспомогательную функцию, следите, чтобы она не засоряла область видимости. Необходимые типы данных уже описаны в файле hw2_provided.ml. Переименуйте его в hw2.ml и допишите туда ваши решения. Кроме того, в файле hw2_tests.ml вы найдёте примеры тестов. Их недостаточно, чтобы протестировать вашу программу, поэтому вам нужно будет дополнить их. В Anytask сдавайте как файл с решениями, так и файл с тестами. Тесты оцениваться не будут, но не работающие решения не засчитываются. Авторское решение занимает примерно 100 строк.*

1. (1) Напишите функцию `merge_int_lists: int list -> int list -> int list`, которая принимает два упорядоченных списка целых чисел, и возвращает новый упорядоченный список, полученный слиянием списков-аргументов.

2. (1) Напишите полиморфную функцию `merge_any_lists: ('a - 'a -> int) -> 'a list -> 'a list -> 'a list`, которая принимает функцию `cmp` (принимает два объекта произвольного типа, и возвращает 0, если элементы равны, -1 если первый меньше, 1 если первый больше) и два упорядоченных списка этого же типа, и возвращает упорядоченный список, полученный слиянием этих двух.

3. (1) Определите функции `merge_string_lists` и `merge_name_lists`. Строки сортируются лексикографически, записи типа `name` - сначала по фамилии, потом по имени. Воспользуйтесь частичным применением аргументов.

```ocaml
type name = {fname: string; sname: string}
```

4. (1) С помощью функции `List.fold_left` определите следующие полиморфные функции над списками:

* `len : 'a list -> int`, которая принимает аргумент-список и возвращает его длину.

* `forall : ('a -> bool) -> 'a list -> bool`, которая применяет свой первый аргумент (предикат) к каждому элементу списка и возвращает true тогда и только тогда, когда для всех элементов предикат вернул true.

* `exists : ('a -> bool) -> 'a list -> bool`, которая применяет свой первый аргумент (предикат) к каждому элементу списка и возвращает true тогда и только тогда, когда хотя бы для одного из элементов предикат вернул true

5. (6) Рассмотрим язык, поддерживающий арифметические (сложение, умножение) и логические ("равно", "меньше") операции, переменные и локальные связывания имён, определение функций от одного аргумента (второго класса), выражения if-then-else, а также целочисленный и логический тип.

Напишите функцию `typecheck`, которая принимает в качестве аргумента выражение `exp`, и возвращает тип этого выражения, если оно типизировано верно, иначе - выбрасывает исключение.

Статическая семантика (типы) выражений языка следующая:

* Целочисленные и логические константы имеют соответственно целочисленный и логический тип

* При обращении к переменной её имя ищется в текущем статическом окружении, и если оно не было найдено, возникает исключение `UndefinedVariable`, иначе типом выражения будет найденный в окружении тип.

* `Add (e1, e2)`, `Mult(e1, e2)`. Если оба подвыражения `e1`, `e2` имеют целочисленный тип, то само выражение имеет целочисленный тип. Иначе - ошибка `TypeError`.

* `Eq (e1, e2)`, `Less (e1, e2)`. Если оба подвыражения `e1`, `e2` имеют целочисленный тип, то само выражение имеет логический тип. Иначе - ошибка `TypeError`.

* Выражение `Let (name, e1, e2)`. Если выражение `e1` имеет тип `t1`, а выражение `e2` имеет тип `t2` в текущем статическом окружении, дополненном парой `(name, t1)`, то тип всего выражения - t2.

* Выражение `Fun(name, tp, e)`(безымянная функция с аргументом `name` типа `tp` и телом `e`). Если тип выражения `e` в текущем статическом окружении, дополненном парой `(name, tp)`, имеет тип `t`, то тип всего выражения - `fun: tp -> t`.

Обратите внимание, что для того, чтобы вызывать функцию по имени, её нужно привязать к имени с помощью `Let`. 

* Выражение `Call(name, e)` (вызов функции с именем `name`). Имя функции ищется в текущем статическом окружении, и если оно не было найдено, возникает исключение `UndefinedVariable`. Если имя `name` связано с типом `fun: t1 -> t2`, и выражение `e` в текущем статическом окружении имеет тип `t1`, то тип всего выражения - `t2`, иначе `TypeError`

* Выражение `If(e1, e2, e3)`. Если тип выражения `e1` - логический, а типы выражений `e2` и `e3` равны `t`, то тип всего выражения равен `t`, иначе - `TypeError`.

Абстрактный синтаксис для нашего языка описывается следующими типами:

```ocaml
type typ =
  | TypI (* int *)
  | TypB (* bool *)
  | TypF of typ * typ (* function: T1 -> T2 *);;

type op = Add | Mult | Eq | Less;;

type expr =
  | ConstI of int
  | ConstB of bool
  | Var of string
  | BinOp of op * expr * expr (* Operation type, first subexpression, second subexpression *)
  | Let of string * expr * expr (* var name, expression to bind, let body *)
  | Fun of string * typ * expr (* parameter name, parameter type, function body *)
  | Call of string * expr (* function name, argument expression *)
  | If of expr * expr * expr (* Text expression, then branch, else branch *);;
```

В результате в вашем файле должны быть следующие связывания:
```ocaml
val merge_int_lists : 'a list -> 'a list -> 'a list = <fun>
val merge_any_lists : ('a -> 'a -> int) -> 'a list -> 'a list -> 'a list = <fun>
val merge_string_lists : String.t list -> String.t list -> String.t list = <fun>
val merge_name_lists : name list -> name list -> name list = <fun>
val len : 'a list -> int = <fun>
val forall : ('a -> bool) -> 'a list -> bool = <fun>
val exists : ('a -> bool) -> 'a list -> bool = <fun>
val typecheck : expr -> typ = <fun>
```
