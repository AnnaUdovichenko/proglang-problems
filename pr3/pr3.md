# Основы Racket

Racket (до 2010 года PLT Scheme) - современный диалект лиспа, динамически-типизированный функциональный язык.

Поскольку язык динамически-типизированный, понятия статического окружения, которое содержит типы сущностей, уже нет. Связывания имён верхнего уровня видны не только ниже, но и выше точки их определения.

Определение значений:
```racket
(define x 3)
(define y (+ x 2))
```

Определяются функции так:

```racket
(define cube ; function
  (lambda (x)
    (* x (* x x))
    ))

; Recursive function with if clause
(define pow
  (lambda (x y)
    (if (= y 0)
        1
        (* x (pow (- y 1)))
        )))
```

Определение безымянной функции:

```racket
(lambda (<arg_list>)
    <body>)
```

Именованная функция определяется через безымянную:
```racket
(define <name> 
    (lambda (<arg_list>)
        <body>))
```

Вызывается функция так:

```racket
(<name> <args>)
```

Условное выражение, как и в OCaml - это выражение:

```racket
(if (<condition>) <then-clause> <else-clause>)
```

Разные ветки могут возвращать значения разного типа, и это нормально:

```racket
(if (< x 8)
    1
    "Hi")
```

Сумма - это на самом деле вызов функции `+` c двумя аргументами - `x` и `2`. Аргументов может быть больше двух:

```racket
(define cube2
    (lambda (x)
        (* x x x)))
```

Синтаксический сахар для определения функций без явного использования `lambda`:

```racket
(define (cube3 x)
    (* x x x))

(define (pow x y)
    (if (= y 0)
    1
    (* x (pow x (- y 1)))))

```

Функции в Racket являются объектами первого класса, поэтому их можно каррировать:

```racket
(define pow-curry
  (lambda (x)
    (lambda (y)
      (if (= y 0)
          1
          (* x ((pow-curry x) (- y 1)))))))

(define three-to-the (pow-curry 3))
(define eightyone (three-to-the 4))
(define sixteen ((pow-curry 2) 4))
```

Поскольку в Racket есть настоящие функции нескольких аргументов, каррирование не так широко используется. Тем не менее, для определения каррированных функций существует синтаксический сахар:

```racket
(define ((pow x) y)
  (if (= y 0)
      1
      (* x ((pow x) (- y 1)))))
```

**Задание** Проверьте, существует ли синтаксический сахар для вызова каррированных функций.

## Работа со списками

В Racket есть встроенные списки, которые используются очень часто. Вот основные функции для создания списков и обращения к их частям:

| Примитив | Описание                                                     | Пример                   |
|----------|--------------------------------------------------------------|--------------------------|
| `null`   | Пустой список                                                | `null`                   |
| `cons`   | Создание списка (из головы и хвоста)                         | `(cons 2 (cons 3 null))` |
| `car`    | Первый элемент (голова) списка                               | `(car some-list))`       |
| `cdr`    | Хвост списка                                                 | `(cdr some-list)`        |
| `null?`  | Возвращает `#t` для пустого списка и `#f` для любого другого | `(null? some-value)`     |

Вместо `null` пустой список можно задавать как `'()`
Встроенная функция для создания списка из произвольного количества аргументов:

```racket
(list 1 2 3)
```

Примеры функций для работы со списками (map и append есть в стандартной библиотеке):

```racket
(define (sum xs)
  (if (null? xs)
      0
      (+ (car xs) (sum (cdr xs)))))

(define (append xs ys)
  (if (null? xs)
      ys
      (cons (car xs) (append (cdr xs) ys))))

(define (map f xs)
  (if (null? xs)
      null
      (cons (f (car xs)) (map f (cdr xs)))))
```

## Типичные способы запутаться в скобках

Преимущества особого лисп-синтаксиса и значение скобок мы обсудим чуть позже. Но пока стоит отметить, что в отличие от других языков, здесь каждая пара скобок имеет значение, и нигде их нельзя добавить или убрать просто так. Вот типичные ошибки, связанные с неправильной расстановкой скобок:

```racket
(define (fact n) (if (= n 0) 1 (* n (fact (- n 1))))) ; 1
(define (fact n) (if (= n 0) (1) (* n (fact (- n 1))))) ; 2
(define (fact n) (if = n 0 1 (* n (fact (- n 1))))) ; 3
(define fact (n) (if (= n 0) 1 (* n (fact (- n 1))))) ; 4
(define (fact n) (if (= n 0) 1 (* n fact (- n 1)))) ; 5
(define (fact n) (if (= n 0) 1 (* n ((fact) (- n 1))))) ; 6
(define (fact n) (if (= n 0) 1 (n * (fact (- n 1))))) ; 7
```

| 2 | Попытка вызвать `1` как функцию без аргументов                           |
|---|--------------------------------------------------------------------------|
| 3 | 5 подвыражений у `if` (вместо 3)                                         |
| 4 | Неправильное определение: `(n)` интерпретируется как подвыражение        |
| 5 | Функция `*` вызывается с функцией `fact` в качестве одного из аргументов |
| 6 | Вызов `fact` без аргументов                                              |
| 7 | `n` интерпретируется как функция с аргументом `*`                        |

В общем, программирование на Racket поначалу требует некоторой концентрации. Будьте внимательны :)

## Гетерогенные списки

Благодаря тому, что Racket динамически типизированный, списки уже не обязаны содержать элементы одного и того же типа. В один список можно сложить что угодно, в том числе другие списки:

```racket
(list #t "Hi" (list 1 3 4))
```

Представим себе список, который содержит либо числа, либо другие списки, содержащие числа (с вложенностью на любую глубину), например:

```racket
(list 2 (list 4 5) (list (list 1 2) (list 6)) 19 (list 14 0))
```

В OCaml нам потребовалось бы создать специальный тип, чтобы хранить такую структуру. Определим функцию, которая суммирует все числа в таком списке:

```racket
(define (sum-all xs)
  (if (null? xs)
      0
      (if (number? (car xs))
          (+ (car xs) (sum-all (cdr xs)))
          (+ (sum-all (car xs)) (sum-all (cdr xs))))))
```

Здесь используются примитивы `number?` и `null?` для определения свойств некоего значения в рантайме. Вторая ветка второго `if` подразумевает, что `xs` является списком, иначе мы получим ошибку времени выполнения.

## Выражение cond

Рассмотрим специальную форму `cond`, которая представляет из себя условное выражение с произвольным количеством веток (чем-то напоминающее сопоставление с образцом). Им часто можно заменить выражения с вложенными `if`, и читаться это будет лучше (квадратные скобки заменяют круглые, для `cond` это стандартный стиль):

```racket
(define (sum-cond xs)
  (cond [(null? xs) 0]
        [(number? (car xs)) (+ (car xs) (sum-cond (cdr xs)))]
        [#t (+ (sum-cond (car xs)) (sum-cond (cdr xs)))]))
```

`cond` принимает произвольное количество выражений `[e1 e2]`. `e1` - это условие, если оно будет вычислено в `#f`, продолжится вычисление следующей ветки. Иначе результатом вычисления всего выражения будет результат вычисления `e2`. Последнюю ветку обычно пишут с условием `#t`, она будет точно выполнена (тут можно оставить обработку ветки по умолчанию)

# Задачи

1.  Напишите функцию `sequence`​, которая принимает аргументы `low`​, `high` ​​(целые числа) и `step` ​(положительное число). Функция `sequence` ​должна возвращать список чисел от `low` ​до `high` с ​шагом `step`​.

2. Напишите функцию `string-append-map`​, которая принимает список строк `xs` ​и  строку `suffix`, ​и возвращает список новых строк, присоединив к каждой строке исходного списка строку `suffix` ​(без пробелов между строкой и суффиксом). Используйте
библиотечные функции `map` ​и `string-append​`.

3. Рассмотрим вложенный список, похожий на тот, что рассмотрен выше, но кроме чисел допускаются элементы другого типа. **[UPD!]** Напишите функцию `sum-indifferent`, которая принимает такой список и суммирует все элементы-числа из этого списка.

4. Напишите функцию `flatten`, которая принимает вложенный список и возвращает "плоский" список из тех же элементов. Используйте функции `append` и `list`.

5. Напишите функцию `duplicate`, которая принимает список и возвращает такой список, в котором все элементы продублированы.