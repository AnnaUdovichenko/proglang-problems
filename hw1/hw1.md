# Древообработка

Язык: **OCaml**

Максимальное количество баллов: **15**

*В данной работе нужно будет написать несколько функций, пользуясь автоматическим выводом типов (явно указывать типы не нужно) и сопоставлением с образцом (вся работа со списками, кортежами, вариантами и записями должна быть через pattern matching, без функций типа List.hd или fst).  Необходимые типы данных уже описаны в файле hw1_provided.ml. Переименуйте его в hw1.ml и допишите туда ваши решения. Кроме того, в файле hw1_tests.ml вы найдёте примеры тестов. Их недостаточно, чтобы протестировать вашу программу, поэтому вам нужно будет дополнить их. В Anytask сдавайте как файл с решениями, так и файл с тестами. Тесты оцениваться не будут, но не работающие решения не засчитываются. Авторское решение занимает примерно 120 строк.*

**UPD!** *Функции для обхода списков нужно писать руками, не заменяя на библиотечные функции высшего порядка. Можно использовать те функции из стандартной библиотеки, которые явно указаны в условиях, либо аналогичные. Для остальных случаев - рекурсия и pattern matching наше всё.*

1. (1) Напишите функцию `is_positive: int list -> bool`, которая принимает список целых чисел и возвращает `true`, если все числа в нём положительные, и `false` в противном случае. Для пустого списка возвращайте true.

2. (1) Напишите функцию `is_sorted: int list -> bool`, которая принимает список целых чисел и возвращает `true`, если он отсортирован в порядке неубывания, и `false` в противном случае. Пустой список считайте отсортированным и возвращайте для него true.

3. Следующие несколько задач - работа с рекурсивным типом для описания бинарных деревьев. 

```ocaml
type int_tree = Lf
        | Br of int * int_tree * int_tree
```

* (1) Напишите функцию `count_branches: int_tree -> int`, которая принимает корень дерева и возвращает количество внутренних узлов (ветка Br) в этом дереве.

* (1) Напишите функцию `depth: int_tree -> int`, которая принимает корень дерева и возвращает его максимальную глубину (`depth Lf` должно вернуть 0).

* (1) Напишите функцию `gen_tree: int -> int_tree`, которая получает целое число n и возвращает корень дерева следующего вида (пример для `gen_tree 3`):

![Дерево-результат вызова gen_tree 3](https://github.com/AnnaUdovichenko/proglang-problems/blob/master/hw1/pic/tree.png)

`gen_tree 0` должно возвращать Lf.

* (1) Напишите функцию `inorder: int_tree -> int list`, которая получает корень дерева и возвращает список значений из узлов в порядке “левое поддерево - корень - правое поддерево”

* (1) Напишите функцию `preorder: int_tree -> int list`, которая получает корень дерева и возвращает список значений из узлов в порядке “корень - левое поддерево - правое поддерево”

4. (3) Следующая задача - обработка записей, хранящих информацию о книгах:

```ocaml
type author_type = {fname: string; sname: string}
type book_type = {author: author_type; name: string; year: int}
```

Напишите функцию `search_book: key -> book_type list -> book_type list`, которая принимает ключевое слово и список книг, и возвращает список книг, в названии которых содержится ключевое слово, либо ключевое слово совпадает с именем или фамилией автора. Ищите полным совпадением, для деления названия книги на слова используйте функцию `String.split_on_char`. Считайте, что в названии нет знаков препинания, кроме пробела.

5. (2) Упрощение логических выражений  
Рассмотрим мини-язык логических выражений с переменными и константами:

```ocaml
type const = True | False
type bool_expr =
 | Const of const
 | Var of string
 | Not of bool_expr
 | And of bool_expr * bool_expr
 | Or of bool_expr * bool_expr
```

Напишите функцию `simplify: bool_expr - > bool_expr`, которая упрощает логическое выражение, применяя следующие правила:

```ocaml
And (False, bool_expr e) == False
And (True, bool_expr e) == bool_expr e
Or (True, bool_expr e) == True
Or (False, bool_expr e) = bool_expr e
```
Не забудьте учесть коммутативность.
**UPD!** Друзья, спасибо за ваши предложения, но в этой задаче другие правила для упрощения логических выражений применять не нужно. Я подумаю над тем, чтобы предложить более сложную версию этой задачи в другой раз ;)

6. Язык letlang  
Рассмотрим мини-язык с поддержкой целочисленных констант, переменных и let-выражений произвольной вложенности. Выражениями этого языка могут быть:
`Const v`, где `v` - целое число. Вычисляется в `Const v`.
`Var name`, где `name` - строка.  Приводит к поиску имени `name` в текущем окружении. Если найдено значение `v`, то оно будет результатом вычисления `Var name`, иначе получаем ошибку времени выполнения (UndefinedVariable exception).
`Let name e1 e2`, где `name` - строка, `e1`, `e2` - выражения языка letlang. `e1` вычисляется в текущем окружении, получаем результат `v1`. `e2` вычисляется в окружении, дополненном связыванием `(name, v1)`. Полученное в результате значение `v2` является результатом выражения `Let name e1 e2`.

Примеры:
`Const 42` вычисляется в `Const 42`
`Let("y", Const 15, Var "y")` вычисляется в `Const 15`
`Let("y", Const 15, Let("y", Const 14, Var "y"))` вычисляется в `Const 14`, поскольку второе вхождение переменной `y` затеняет первое.

```ocaml
exception UndefinedVariable of string

type letlang_expr = 
  Const of int
  | Var of string
  | Let of string * letlang_expr * letlang_expr;;
```

* (1) Напишите функцию `lookup: string -> (string * letlang_expr) list -> letlang_expr option`, которая принимает имя переменной `var` в виде строки и окружение в виде списка пар `(name, value)`. Функция должна возвращать `None`, если в списке нет связывания для имени `var`, и `Some v`, если пара `(var, v)` - первая в списке.
  
* (2) Напишите функцию `eval: letlang_expr -> letlang_expr`, которая принимает выражение и возвращает результат его вычисления. Используйте локальную рекурсивную вспомогательную функцию `eval_env: letlang_expr -> (string * letlang_expr) -> letlang_expr`, которая принимает выражение и текущее окружение в виде списка пар `(name, v)`, и возвращает результат выражения, вычисленного в текущем окружении, или бросает исключение, если в процессе вычисления было обращение к имени, которого в окружении нет (имя, которое не было найдено, передайте в исключение как параметр). Вызовите её из `eval` с пустым окружением.

В результате в вашем файле должны быть следующие связывания:
```ocaml
val is_positive : int list -> bool = <fun>
val is_sorted : 'a list -> bool = <fun>
val count_branches : int_tree -> int = <fun>
val depth : int_tree -> int = <fun>
val gen_tree : int -> int_tree = <fun>
val inorder : int_tree -> int list = <fun>
val preorder : int_tree -> int list = <fun>
val search_book : string -> book_type list -> book_type list = <fun>
val simplify : bool_expr -> bool_expr = <fun>
val lookup : 'a -> ('a * 'b) list -> 'b option = <fun>
val eval : letlang_expr -> letlang_expr = <fun>
```
