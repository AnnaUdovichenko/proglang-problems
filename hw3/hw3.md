# Реки памяти

Язык:​ **Racket**

Максимальное количество баллов: **11**

*В этой работе нужно написать несколько функций на Racket, в основном связанных с отложенными вычислениями и мемоизацией. Избегайте повторного вычисления одинаковых выражений. Переиспользуйте код, где это возможно.*

1. (1) Напишите функцию `list-nth-mod`, которая принимает список `xs` и число `n`. Если `n` отрицательное, остановите выполнение с `(error "list-nth-mod: negative number")`. Если список пустой, остановите выполнение с `(error "list-nth-mod: empty list")`. Иначе, верните i-й элемент списка, где `i` - остаток от деления `n` на длину исходного списка. Подсказка: библиотечные функции `length`, `remainder`, `car`, `list-tail` могут здесь пригодиться.
   
2. (1) Напишите функцию `stream-for-n-steps`, которая принимает стрим `s` и  число `n`, и возвращает список из первых `n` значений, порождённых стримом. Считайте, что `n` неотрицательное.
   
3. (1) Напишите функцию `stream-map`, которая принимает стрим `s` и функцию `f`, и возвращает стрим, каждый элемент которого является результатом применения `f` к соответствующим элементам исходного стрима.
   
4. (1) Напишите функцию `combine-streams`, которая принимает стримы `s1` и `s2` и функцию `f`, и возвращает стрим, каждый элемент которого является  результатом применения `f` к соответствующим элементам первого и второго стрима.
Например:

```
s1: 1, 2, 3, ...
s2: 2, 3, 4, ... ...
(combine-streams s1 s2 +): 3, 5, 7, ...
```

5. (1) Напишите функцию `skip-first-n`, которая принимает стрим `s` и число `n`, и возвращает стрим, генерирующий элементы исходного стрима, начиная с `n+1` по счёту.
   
6. (1)
    * Напишите функцию `funny-number-stream`, которая похожа на стрим натуральных чисел за исключением того, что все числа, кратные 5 - отрицательные (то есть 1, 2, 3, 4, -5, 6, 7, 8, 9, -10 ...).
    * Напишите функцию `squares`, которая принимает стрим `s` и возвращает стрим, элементы которого являются квадратами элементов исходного стрима. Помните, что стрим - это thunk, который при вызове возвращает пару `(результат . новый стрим)`.
   
7. (2) Напишите функцию `taylor`, которая принимает число `x`, и возвращает стрим, элементы которого являются слагаемыми ряда Тейлора для натурального  логарифма по формуле:
   
   ![equation](https://latex.codecogs.com/gif.latex?ln%28x&plus;1%29%20%3D%20%5Csum_%7Bn%3D1%7D%5E%7B%5Cinfty%20%7D%5Cfrac%7B%28-1%29%5E%7Bn-1%7Dx%5E%7Bn%7D%7D%7Bn%7D)

1. (1) Напишите функцию `cycle-lists`, которая принимает два списка `xs` и `ys` (списки могут быть разной длины, но не пустые) и возвращает стрим, элементы стрима - это пары, где первая часть - элемент из `xs`, вторая - элемент из `ys`. Например, если `xs` равен `'(1, 2, 3)`, а `ys` - `'("a", "b")`, то стрим будет генерировать значения `(1 . "a")`, `(2 . "b")`, `(3 . "a")`, `(1 . "b")`, `(2 . "a")`, `(3 . "b")`, `(1. "a")`, `(2 . "b")` и т. д.

2.  (2) Напишите функцию `stairs`, которая принимает число `n` и возвращает количество способов подняться на лестницу из `n` ступенек, если длины ног хватает на то, чтобы перепрыгивать через одну ступеньку или через две. Например, на лестницу из двух ступенек можно подняться двумя способами: сначала стать на первую, потом на вторую, либо прыгнуть сразу на вторую. Ограничения: `0 <= n <= 100`. Подсказка: определите рекурсивную функцию с мемоизацией в векторе (`vector` из стандартной библиотеки Racket).

3.  (3) Задача-бонус. Напишите функцию `stairs2`, которая принимает два числа - `n` и `k`, и возвращает количество способов подняться на лестницу из `n` ступенек (как в предыдущей задаче), с дополнительным ограничением: сил хватит не больше чем на `k` прыжков через 2 ступеньки. Ограничения: `0 <= n <= 100`, `0 <= k <= 100`.
